:PROPERTIES:
:ID:       805a8d3f-4aaa-44d6-b6e6-015316b20981
:END:
#+title: Grokking Functional Programming
#+filetags: :Functional_Programming:Manning_Books:

* Chapter 1
** Imperative vs. declarative
:PROPERTIES:
:ID:       796de48e-28fa-427e-a12c-40f8e8980502
:END:

- [[id:fda18a87-d310-45bd-b1c9-69d470b76f1a][Imperative]] programming focuses on _how_ the result should be computed.
- [[id:cb54393a-8404-4632-bef5-ecd6b4897150][Declarative]] programming focuses on _what_ needs to be done.

Functional Programming generally tries to be as _declarative_ as possible.

#+BEGIN_SRC java
public static int calculateScore(String word) {
    int score = 0;
    for(char c : word.toCharArray()) {
        score++;
    }
    return score;
}

public static int wordScore(String word) {
    return word.length();
}
#+END_SRC

~calculateScore~ is written _imperatively_, while ~wordScore~ is written _declaratively_.

*** Coffee break exercise
Modify the ~calculateScore~ and ~wordScore~ functions so that the score equals the number of letters different than ~a~.

The following should be true:

#+BEGIN_COMMENT
calculateScore("imperative") == 9     wordScore("declarative") == 9
calculateScore("no") == 2             wordScore("yes") == 3
#+END_COMMENT

#+BEGIN_SRC java
public static int calculateScore(String word) {
    int score = 0;
    for(char c : word.toCharArray()) {
        if (char != 'a') {
            score++;
        }
    }
    return score;
}

public static int wordScore(String word) {
    return word.replace("a", "").length();
}
#+END_SRC


Alternate declarative answer:

#+BEGIN_SRC java
public static String stringWithoutChar(String s, char c) {
    return s.replace(Character.toString(c), "");
}

public static int wordScore(String word)  {
    return stringWithoutChar(word, 'a').length();
}
#+END_SRC

** Meet the function... in [[id:54edfb9f-3852-44e7-9a53-a56d743d101d][Scala]]

#+BEGIN_SRC java
public static int add(int a, int b) {
    return a + b;
}
#+END_SRC

The same function written in [[id:54edfb9f-3852-44e7-9a53-a56d743d101d][Scala]]:

#+BEGIN_SRC scala
def add(a: Int, b: Int): Int = {
  a + b
}
#+END_SRC


** Practice Section: Rewrite functions from Java to Scala

#+BEGIN_SRC java
public static int increment(int x) {
    return x + 1;
}

public static char getFirstCharacter(String s) {
    return s.charAt(0);
}

public static int wordScore(String word)  {
    return word.length();
}
#+END_SRC

#+BEGIN_SRC scala
def increment(x: Int): Int = {
  x + 1
}

def getFirstCharacter(s: String): Char = {
  s.charAt(0)
}

def wordScore(word: String): Int = {
  word.length()
}
#+END_SRC

* Chapter 2 - [[id:a80f9e5d-1455-43e7-b876-28c891f3156c][Pure Functions]]
** Separation of Concerns
#+BEGIN_QUOTE
In [[id:ddff8999-8f7a-4abe-b756-af97af50dfdc][Functional Programming]], we separate concerns into different functions.
#+END_QUOTE

** The three rules of pure functions
1. A pure function always returns a single value.
2. A pure function calculates the return value based only on its arguments.
3. A pure function doesn't mutate any existing values.


** Coffee break: Refactoring to a pure function

Before:
#+BEGIN_SRC java
class TipCalculator {
 private List<String> names = new ArrayList<>();
 private int tipPercentage = 0;

 public void addPerson(String name) {
   names.add(name);
   if(names.size() > 5) {
     tipPercentage = 20;
   } else if(names.size() > 0) {
     tipPercentage = 10;
   }
 }

 public List<String> getNames() {
   return names;
 }

 public int getTipPercentage() {
   return tipPercentage;
 }
}
#+END_SRC

After:
#+BEGIN_SRC java
class TipCalculator {
    public static int getTipPercentage(List<String> names) {
        if (names.size() > 5) {
            return 20;
        } else if (names.size() > 0) {
            return 10;
        }

        return 0;
    }
}
#+END_SRC

** Referential transparency
Referential transparency means that a function can be called any time, as many times as we want, and it will /always/ return the same value.

If the function only uses its arguments to compute a value, and it doesn't mutate any existing values, it automatically becomes referentially transparent.

** Using Scala to write pure functions
Example of the shopping cart discount calculator in Java:

#+BEGIN_SRC java
class ShoppingCart {
    public static int getDiscountPercentage(List<String> items) {
        if(items.contains("Book")) {
            return 5;
        } else {
            return 0;
        }
    }
}
#+END_SRC

Same example, in Scala:
#+BEGIN_SRC scala
object ShoppingCart {
  def getDiscountPercentage(items: List[String]): Int = {
    if (items.contains("Book")) {
      5
    } else {
      0
    }
  }
}
#+END_SRC

Tip Calculator in Java:
#+BEGIN_SRC java
class TipCalculator {
    public static int getTipPercentage(List<String> names) {
        if(names.size() > 5) {
            return 20;
        } else if(names.size() > 0) {
            return 10;
        } else return 0;
    }
}
#+END_SRC

Tip Calculator in Scala:
#+BEGIN_SRC scala
object TipCalculator {
  def getTipPercentage(names: List[String]): Int = {
    if (names.size() > 5) 20
    else if (names.size() > 0) 10
    else 0
  }
}
#+END_SRC

* Chapter 3 - Immutable Values
** Shared mutable state
Shared mutable state is state (variables, data structures, etc.) that is shared in multiple places across a program, that can be mutated.

This causes higher cognitive load for the programmer, as you must know the places where this state can be modified to truly understand what's happening.

There are a few ways to deal with this.

1. Copy the value in your function
2. The [[id:5f847578-387b-47f2-9c6c-18aa0e899ebf][Object Oriented]] way, encapsulating the mutable state in an object (perhaps as a private variable).
3. The [[id:ddff8999-8f7a-4abe-b756-af97af50dfdc][Functional Programming]] way, using immutable state (this is gaining traction in [[id:5f847578-387b-47f2-9c6c-18aa0e899ebf][Object Oriented]] programming as well).

** Immutability in [[id:ddff8999-8f7a-4abe-b756-af97af50dfdc][Functional Programming]] languages
Functional languages support immutability in their data structures by default. For example, [[id:54edfb9f-3852-44e7-9a53-a56d743d101d][Scala]]'s List data structure is immutable, so you can trust that operations on it will not alter the original list.

** Coffee break - The immutable ~String~ API
Task: Implement an =abbreviate= function in [[id:54edfb9f-3852-44e7-9a53-a56d743d101d][Scala]], which takes a name like "Alonso Church", and returns "A. Church".

Sample inputs & outputs:
| Input         | Output    |
|---------------+-----------|
| Alonso Church | A. Church |
| A. Church     | A. Church |
| A Church      | A. Church |

#+BEGIN_SRC scala
def abbreviate(name: String): String = {
  val firstNameInitial = name.substring(0, 1)
  val separator = name.indexOf(' ')
  val lastName = name.substring(separator + 1)

  firstNameInitial + ". " + lastName
}
#+END_SRC

** Aren't immutable values worse for performance?
Yes, but in most cases, this won't matter. What will matter a lot more is how easy something is for the developer.

** Exercises: Practicing immutable slicing and appending
*** Exercise: Write a function called ~firstTwo~
#+BEGIN_SRC scala
def firstTwo(list: List[String]): List[String] = {
  list.take(2)
}
#+END_SRC

*** Exercise: Write a function called ~lastTwo~
#+BEGIN_SRC scala
def lastTwo(list: List[String]): List[String] = {
  list.takeRight(2)
}
#+END_SRC

*** Exercise: Write a function called ~movedFirstTwoToTheEnd~
#+BEGIN_SRC scala
def moveFirstTwoToTheEnd(list: List[String]): List[String] = {
  list.drop(2).appendedAll(list.take(2))
}
#+END_SRC
