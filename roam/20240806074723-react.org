:PROPERTIES:
:ID:       bb077623-5540-4767-b6d9-ae4301af5ef2
:END:
#+title: React

React is a [[id:ccd90ef7-390c-4623-9a21-49340850109b][Javascript]] framework that evangelists insist is a library. It is divine punishment for straying from the holy path of [[id:e32c438b-71d7-4647-9132-62d852feee48][jQuery]].

React emphasizes a [[id:cb54393a-8404-4632-bef5-ecd6b4897150][declarative]] style of programming.

React uses the [[id:7c44002d-fa4f-48cf-a98a-10accc14f54b][Virtual DOM]] to make updates.

React uses [[id:a91b6fb3-4209-45d0-80d1-6fa59b70a746][JSX]] to create [[id:b785b344-47c9-4993-96a6-6a267af835b1][HTML]].

* Advantages
** Simplicity
[[id:a91b6fb3-4209-45d0-80d1-6fa59b70a746][JSX]] and React itself are simple (at least when getting started).
** Testability
The [[id:7c44002d-fa4f-48cf-a98a-10accc14f54b][Virtual DOM]] allows testing to occur without needing to run a headless browser.
** Ecosystem
Pretty much everybody uses React these days. There are libraries for everything, and everyone has touched React at least once in their career.
* Disadvantages
** Not a complete solution
You will certainly need to reach for other libraries to do anything that isn't arbitraty
** Constant library maintenance
[[id:ccd90ef7-390c-4623-9a21-49340850109b][Javascript]] has a messy ecosystem. Things constantly break, and libraries are replaced.
** One way binding
React only supports one way binding, unlike other web frameworks with two way binding.

* Functional Components
:PROPERTIES:
:ID:       6b73a030-c9ac-4ad0-9685-2982871e94a1
:END:

Functional components are how all the cool kids are doing [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] these days.

** Arguments to the function
Functional Components can only receive *one* argument: a frozen object of properties.

** Destructuring properties
It is common practice to write functional components with a destructured first argument. This ensures that the function does not have a ton of arguments as its scope grows.

#+BEGIN_SRC javascript
...
function MenuItem({ href, label }) {
  return (
    <li className="menu-item">
      <a className="menu-link" href={href}>
        {label}
      </a>
    </li>
  );
}
...
#+END_SRC

A benefit of this approach is that you can specify default arguments.

#+BEGIN_SRC javascript
...
function Menu() {
  return (
    <nav className="navbar">
      <h1 className="title">TheMenuCompany</h1>
      <ul className="menu">
        <MenuItem label="Home" href="/" />
        <MenuItem label="About" href="/about/" />
        <MenuItem
          label="Blog" href="/blog" target="_blank"
        />
      </ul>
    </nav>
  );
}
function MenuItem({ label, href, target = "_self" }) {
  return (
    <li className="menu-item">
      <a
        className="menu-link"
        href={href}
        target={target}
      >
        {label}
      </a>
    </li>
  );
}
...

#+END_SRC

The ordering of the properties does not matter, but it's common practice to put those with defaults at the end.

** Pass through properties
Sometimes, an argument to a functional component is needed by its children, but not the component itself. The [[id:c66f10cf-8136-430a-8b7c-17b259490cc2][rest operator]] can come in handy here.

#+BEGIN_SRC javascript
function MyComponent({ a, b, ...rest }) {
 // a = 1, b = 2, rest = { c: 3 }
}
// Later:
<MyComponent a="1" b="2" c="3" />
#+END_SRC

It's convention to list out the required properties in the function signature, and leave the unneeded ones as a [[id:c66f10cf-8136-430a-8b7c-17b259490cc2][rest operator]].

#+BEGIN_SRC javascript
...
function MenuItem({ label, href, ...rest }) {
  return (
    <li className="menu-item">
      <a className="menu-link" href={href} {...rest}>
        {label}
      </a>
    </li>
  );
}
...
#+END_SRC

** Argument ordering
The most common way to order arguments in a functional component is:
1. Properties without defaults
2. Properties with defaults
3. Rest


** Lack of constructors
Class based [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] components have constructors, which run only when the component is created. [[id:6b73a030-c9ac-4ad0-9685-2982871e94a1][Functional Components]] do not. The function itself re-runs in its entirety on each re-render.

To replicate the effects of a constructor (something that only runs once upon creation), use [[id:89258539-a6ec-41ef-b4c3-ab696277ac30][useMemo]].

Here's an example where an image component generates a random ID, but only once.

#+BEGIN_SRC javascript
import { useMemo } from 'react';
...
function Image({ index, title }) {
  const id = useMemo(() =>
    `image-${Math.floor(Math.random() * 1000000)}`,
  []);
  return (
    <figure style={{ margin: "5px" }} id={id}>
      <img src={`//picsum.photos/id/${index}/150/150/`} alt={title} />
      <figcaption>
        <h3>Species: {title}</h3>
      </figcaption>
    </figure>
  );
}
...
#+END_SRC

** Re-rendering
A functional component will re-render in one of the following scenarios:
- The component just mounted.
- The parent component re-rendered.
- The component uses stateful hooks, which have updated.

* Stateless components vs. stateful
Components that depend only on their properties and have no internal logic beyond that are called *stateless componenets*. The opposite is *stateful components*, which do have some internal state.

While almost all [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] *applications* are stateful, not all *components* are stateful.

- Stateful components are independent of their contexts, and have the ability to update theirselves based on internal triggers.
- Stateless components can only change or update when their parent component provides new properties.

** Where does state go?
Generally, state should go as close to the component that actually needs it.

** What kinds of information goes in component state?
*** Application data
Data that the user is working on, updating, or reading. Example: information about a logged in user. Often stored globally, or in a data store.
*** UI state
The current state of UI components. Should generally be kept local.
*** Form data
Usually kept in component state.

** What not to store in state?
*** Values that don't change
*** Copies of other state values
*** Duplicates of the same data

* Hooks
:PROPERTIES:
:ID:       30b7d3af-03c7-4534-8386-4e0b9009f8dd
:END:

"Hook" is an umbrella term for a special kind of function in [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] 16.8 and above. There are many built in hooks, and it's possible to create custom hooks as well (should start with =use*=).

Hooks don't all do the same kinds of things. Hooks are hooks because [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] says they are.

They're called hooks because they are hooks *from* your component *to* the "insides" of [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]]. They allow doing things that aren't normally possible.

Hooks *must* always run in a component's render. That is, you cannot conditionally run a hook in an ~if~ statement or something similar.

** useState
:PROPERTIES:
:ID:       072acfe3-f6b5-4f03-9675-5a56f2320415
:END:

~useState~ is a hook that allows for state manipulation.

To use it, provide an initial value, as well as a variable and setter function. In the below example, ~counter~ holds the value (initially ~0~), and ~setCounter~ is the setter function that will update that value.

#+BEGIN_SRC javascript
import { useState } from "react";
function Counter() {
  const [counter, setCounter] = useState(0);
  return (
    <main>
      <p>Clicks: {counter}</p>
      <button
        onClick={() => setCounter((value) => value + 1)}
      >
        Increment
      </button>
    </main>
  );
}
function App() {
  return <Counter />;
}
export default App;
#+END_SRC

It's common practice to name the state itself after what's stored in it (~counter~ here), and name the setter as =set*= (so ~setCounter~). This isn't mandatory, but most [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] developers will do this.

~useState~ must be called with an initial value. Otherwise, the initial value is assumed to be [[id:ef839e85-abd9-45fd-867c-4933be461e39][undefined]]. This is used to set up a baseline value for the component. It will only be used on the initial render.

It's possible to give an initial value from the componenet's props as well.

#+BEGIN_SRC javascript
import { useState } from "react";
function Counter({ start }) {
  const [counter, setCounter] = useState(start);
  return (
    <main>
      <p>Counter: {counter}</p>
      <button onClick={() => setCounter(value => value + 1)}>
        Increment
      </button>
    </main>
  );
}
function App() {
  return (
    <>
      <Counter start={0} />
      <Counter start={123} />
      <Counter start={-64} />
    </>
  );
}
export default App;
#+END_SRC

Sometimes, the initial value must be computed. Here is an example of calling a function for the initial value:

#+BEGIN_SRC javascript
const [password, setPassword] = useState(() => generatePassword());
#+END_SRC

And here's an example of an initializer function that takes an argument.

#+BEGIN_SRC javascript
const [password, setPassword] = useState(() => generatePassword(12));
#+END_SRC

What if the state *is* a function? For example, if we have a "calculator" that needs to set the state to a function.

#+BEGIN_SRC javascript
const OPERATORS = {
 ADDITION: (a, b) => a + b,
 SUBTRACTION: (a, b) => a - b,
 PRODUCT: (a, b) => a * b,
};

function Calculator() {
 const [operator, setOperator] = useState(() => OPERATORS.ADDITION);
 ...
}
#+END_SRC

Note that the component won't re-render unless the state value actually changes. So if you use the setter function and set the value to what it currently is, [[id:bb077623-5540-4767-b6d9-ae4301af5ef2][React]] will not re-render the component.

This has important implications for things like arrays and objects, because changing those doesn't cause a re-render. Because the *reference* is the same, the internal values aren't checked.

For arrays, you can copy the array and set that new array to the state value. So when deleting something from an array, create a copy without the thing you want to delete. When adding to an array, create a copy with the new item, and set that to the state.

** useMemo
:PROPERTIES:
:ID:       89258539-a6ec-41ef-b4c3-ab696277ac30
:END:

TODO

** useEffect
:PROPERTIES:
:ID:       4151f221-bf11-4e97-901e-33eb8a547cc0
:END:

[[id:4151f221-bf11-4e97-901e-33eb8a547cc0][useEffect]] is triggered when any value in a set of dependencies change.

[[id:4151f221-bf11-4e97-901e-33eb8a547cc0][useEffect]] also allows defining a "cleanup" function that can run in one of two cases:
- Before the effect is triggered again
- If the component unmounts.

Here are some likely scenarios to use [[id:4151f221-bf11-4e97-901e-33eb8a547cc0][useEffect]]:
- Loading external data in a component. Will want to do this when the component mounts.
- Creating a timer with an interval.
- Track when a dialog is closed. Can run an effect when the component unmounts.
- Update the browser window title with the page currently displayed.
- Run a timer, but only when an ~isActive~ flag is true.

** useReducer
:PROPERTIES:
:ID:       a5007b76-578d-4d98-b890-2661828a5f4d
:END:

[[id:a5007b76-578d-4d98-b890-2661828a5f4d][useReducer]] is a stateful hook which serves as an advanced version of [[id:072acfe3-f6b5-4f03-9675-5a56f2320415][useState]]. It's a good way to generate a new state solely based on the current state and some action that takes a payload.

[[id:a5007b76-578d-4d98-b890-2661828a5f4d][useReducer]] is never strictly necessary - anything possible with it can be done with a combination of [[id:072acfe3-f6b5-4f03-9675-5a56f2320415][useState]]s.

TODO: Examples

** useRef
:PROPERTIES:
:ID:       9ca29879-3648-4bf0-8338-7ec862662aa7
:END:

[[id:9ca29879-3648-4bf0-8338-7ec862662aa7][useRef]] is a hook with _passive state_, which means that it contains state, but setting or updating it does not re-render the component.

It can be useful for storing references to [[id:d99e159b-96af-4464-831b-b812e5621144][DOM]] elements (hence the name) and remembering values between renders.

To read or update the value of a [[id:9ca29879-3648-4bf0-8338-7ec862662aa7][useRef]] hook, access the ~.current~ property on the hook return value.

*** Example: Click counter
We want to increment a counter only when the user double-clicks a button. We need to store the timestamp of when the user last clicked the button. Another click close enough to that timestamp will count as a double-click.

We could store the last click time using [[id:072acfe3-f6b5-4f03-9675-5a56f2320415][useState]], but that would cause the component to re-render for each click. That's inefficent, so we can instead use [[id:9ca29879-3648-4bf0-8338-7ec862662aa7][useRef]] to store the click time. This will ensure we don't re-render the component unnecessarily.

#+BEGIN_SRC javascript
import { useState, useRef } from "react";
const THRESHOLD = 300;
function DoubleClickCounter() {
  const [counter, setCounter] = useState(0);
  const lastClickTime = useRef(null);
  const onClick = () => {
    const isDoubleClick =
      Date.now() - lastClickTime.current < THRESHOLD;
    if (isDoubleClick) {
      setCounter((value) => value + 1);
    } else {
      lastClickTime.current = Date.now();
    }
  };
  return (
    <main>
      <p>Counter: {counter}</p>
      <button onClick={onClick}>Increment</button>
    </main>
  );
}
function App() {
  return <DoubleClickCounter />;
}
export default App;
#+END_SRC

*** Example: Reference to a [[id:d99e159b-96af-4464-831b-b812e5621144][DOM]] element
#+BEGIN_SRC javascript
function AutoFocusInput() {
  const ref = useRef();
  useEffect(() => ref.current.focus(), []);
  return <input ref={ref} />;
}
#+END_SRC

** useContext
:PROPERTIES:
:ID:       7a4d6456-508c-43c9-a857-4dd958d49b0c
:END:

[[id:7a4d6456-508c-43c9-a857-4dd958d49b0c][useContext]] is a stateful hook, which works in a store in a parent component somewhere up the component tree.

TODO: More info and examples here.

** useCallback
:PROPERTIES:
:ID:       94f60755-6b1c-4ed1-937d-35128d29715a
:END:

[[id:94f60755-6b1c-4ed1-937d-35128d29715a][useCallback]] is a specialized version of [[id:89258539-a6ec-41ef-b4c3-ab696277ac30][useMemo]], which is useful when [[id:89258539-a6ec-41ef-b4c3-ab696277ac30][useMemo]] is used to memoize a function.

TODO: More info and examples here.
